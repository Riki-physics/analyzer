<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>等間隔マーカー実験 x-t / v-t グラフ</title>
  <style>
    :root {
      --bg: #0f172a;
      --card-bg: #0b1120;
      --accent: #38bdf8;
      --border-soft: #1e293b;
      --text-main: #e5e7eb;
      --text-sub: #9ca3af;
    }
    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 1rem;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
      color: var(--text-main);
    }

    .app {
      max-width: 1100px;
      margin: 0 auto;
    }

    header { margin-bottom: 1rem; }

    h1 {
      font-size: 1.4rem;
      font-weight: 700;
      display: flex;
      align-items: baseline;
      gap: 0.4rem;
      letter-spacing: 0.03em;
    }
    h1 span.accent {
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 500;
    }

    .controls {
      background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      padding: 0.75rem 0.9rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      box-shadow: 0 14px 35px rgba(15,23,42,0.75);
    }
    .controls-main {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
    }

    label {
      font-size: 0.9rem;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.2);
      background: rgba(15,23,42,0.8);
    }
    label span.tag {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    input[type="number"] {
      width: 4rem;
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: #020617;
      color: var(--text-main);
      font-size: 0.9rem;
    }

    input[type="range"] {
      width: 120px;
    }

    button {
      font-size: 0.9rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid transparent;
      cursor: pointer;
      background: #020617;
      color: var(--text-sub);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease, transform 0.05s ease;
    }
    button:hover {
      transform: translateY(-1px);
      border-color: rgba(148,163,184,0.6);
    }

    .hint {
      font-size: 0.78rem;
      color: var(--text-sub);
      line-height: 1.4;
      margin-left: auto;
      max-width: 380px;
    }

    .tap-area-wrapper {
      margin-top: 0.9rem;
      display: flex;
      justify-content: center;
    }
    #tapButton {
      width: min(420px, 100%);
      height: 22vh;
      min-height: 130px;
      max-height: 220px;
      font-size: 1.3rem;
      font-weight: 650;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.4);
      background: radial-gradient(circle at top, rgba(56,189,248,0.2), rgba(15,23,42,0.95));
      box-shadow:
        0 18px 35px rgba(15,23,42,0.9),
        0 0 0 1px rgba(148,163,184,0.35);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
    }
    #tapButton span.sub {
      font-size: 0.8rem;
      color: var(--text-sub);
      font-weight: 400;
    }
    #tapButton:active {
      transform: translateY(2px) scale(0.99);
      box-shadow:
        0 10px 20px rgba(15,23,42,0.8),
        0 0 0 1px rgba(56,189,248,0.7);
      background: radial-gradient(circle at top, rgba(56,189,248,0.32), rgba(15,23,42,0.98));
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 0.8rem;
      margin-top: 0.8rem;
    }
    @media (max-width: 980px) {
      .layout {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      }
    }
    @media (max-width: 780px) {
      .controls { flex-direction: column; align-items: flex-start; }
      .hint { margin-left: 0; }
      .layout { grid-template-columns: minmax(0, 1fr); }
    }

    .card {
      background: linear-gradient(145deg, rgba(15,23,42,0.96), rgba(15,23,42,0.995));
      border-radius: 14px;
      border: 1px solid rgba(30,64,175,0.6);
      padding: 0.55rem 0.7rem 0.65rem;
      box-shadow: 0 12px 30px rgba(15,23,42,0.85);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(56,189,248,0.05), transparent 60%);
      pointer-events: none;
    }

    .card h2 {
      font-size: 0.98rem;
      margin: 0 0 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      letter-spacing: 0.02em;
    }
    .card h2 span.badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(56,189,248,0.65);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .small {
      font-size: 0.78rem;
      color: var(--text-sub);
      line-height: 1.4;
      margin-top: 0.3rem;
    }

    canvas {
      width: 100%;
      height: 200px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.9), #020617);
      border-radius: 10px;
      border: 1px solid rgba(15,23,42,0.9);
      display: block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.76rem;
      color: var(--text-main);
    }
    th, td {
      border-bottom: 1px solid rgba(30,41,59,0.9);
      padding: 0.15rem 0.25rem;
      text-align: right;
      white-space: nowrap;
    }
    th {
      font-weight: 600;
      color: var(--text-sub);
      background: rgba(15,23,42,0.9);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tbody tr:nth-child(2n) td { background: rgba(15,23,42,0.85); }
    tbody tr:nth-child(2n+1) td { background: rgba(15,23,42,0.98); }
    tbody tr:hover td { background: rgba(56,189,248,0.08); }

    td:first-child, th:first-child { text-align: center; }

    .table-wrap {
      max-height: 260px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(30,64,175,0.7);
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.9);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        等間隔マーカー実験
        <span class="accent">Tap → x-t / v-t graph</span>
      </h1>
    </header>

    <section class="controls">
      <div class="controls-main">
        <label>
          <span class="tag">marker</span>
          Δx:
          <input id="dxSlider" type="range" min="0.01" max="1.00" step="0.01" value="0.10" />
          <input id="dxInput" type="number" step="0.01" value="0.10" /> m
        </label>
        <button id="startButton">▶ 測定開始</button>
        <button id="stopButton">■ 測定終了</button>
        <button id="resetButton">⟳ リセット</button>
      </div>
      <div class="hint">
        <strong>「測定開始」</strong>を押してから、物体がマーカーを通過する瞬間に下のエリアをタップしてください。<br>
        1回目のタップを <strong>x = 0</strong> とし、
        <strong>x = (タップ番号 − 1) × Δx</strong> として計算します。<br>
        キーボードの <strong>Space</strong> キーでも記録できます。<br>
        測定を終えたら<strong>「測定終了」</strong>を押してください。
      </div>
    </section>

    <div class="tap-area-wrapper">
      <button id="tapButton">
        タップして記録
        <span class="sub">（測定中のみ有効 / Space キーも可）</span>
      </button>
    </div>

    <section class="layout">
      <article class="card">
        <h2>
          データ一覧
          <span class="badge">log</span>
        </h2>
        <div class="table-wrap">
          <table id="dataTable">
            <thead>
              <tr>
                <th>#</th>
                <th>t [s]</th>
                <th>x [m]</th>
                <th>区間Δt [s]</th>
                <th>区間v [m/s]</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </article>

      <article class="card">
        <h2>
          x-t グラフ
          <span class="badge">position</span>
        </h2>
        <canvas id="xtCanvas" width="400" height="240"></canvas>
      </article>

      <article class="card">
        <h2>
          v-t グラフ
          <span class="badge">velocity & a</span>
        </h2>
        <canvas id="vtCanvas" width="400" height="240"></canvas>
        <div class="small">
          v は「2点間の平均速度」。プロットした時刻は、その区間の <strong>時間の中点</strong> です。<br>
          v-t グラフの<strong>傾き（最小二乗直線の傾き）</strong>を平均加速度 a とみなします。<br>
          現在の推定値：<strong id="aDisplay">a: -</strong>（単位：m/s²）
        </div>
      </article>
    </section>
  </div>

<script>
/* -----------------------------
   データ管理
----------------------------- */
let tapTimes = [];
let positions = [];
let vTimes = [];
let velocities = [];

let startTime = null;
let isMeasuring = false;

const dxInput     = document.getElementById('dxInput');
const dxSlider    = document.getElementById('dxSlider');
const tapButton   = document.getElementById('tapButton');
const startButton = document.getElementById('startButton');
const stopButton  = document.getElementById('stopButton');
const resetButton = document.getElementById('resetButton');
const dataTableBody = document.querySelector('#dataTable tbody');

const xtCanvas = document.getElementById('xtCanvas');
const vtCanvas = document.getElementById('vtCanvas');
const aDisplay = document.getElementById('aDisplay');

function nowSec() {
  return performance.now() / 1000;
}

/* -----------------------------
   Δx 入力とスライダーの連動
----------------------------- */
dxSlider.addEventListener('input', () => {
  dxInput.value = parseFloat(dxSlider.value).toFixed(2);
});
dxInput.addEventListener('input', () => {
  const v = parseFloat(dxInput.value);
  if (!isNaN(v)) {
    const clamped = Math.min(1.0, Math.max(0.01, v));
    dxInput.value = clamped.toFixed(2);
    dxSlider.value = clamped.toFixed(2);
  }
});

/* -----------------------------
   リセット
----------------------------- */
function resetAll() {
  tapTimes = [];
  positions = [];
  vTimes = [];
  velocities = [];
  startTime = null;
  dataTableBody.innerHTML = '';
  clearCanvas(xtCanvas);
  clearCanvas(vtCanvas);
  if (aDisplay) aDisplay.textContent = 'a: -';
}

/* -----------------------------
   測定開始・終了
----------------------------- */
function startMeasurement() {
  resetAll();
  isMeasuring = true;
}

function stopMeasurement() {
  isMeasuring = false;
}

/* -----------------------------
   タップ処理
----------------------------- */
function handleTap() {
  if (!isMeasuring) return;  // 測定中でなければ無視

  const dx = parseFloat(dxInput.value) || 0.1;
  const tNow = nowSec();

  if (startTime === null) startTime = tNow;
  const t = tNow - startTime;

  const index = tapTimes.length;
  const x = index * dx;

  tapTimes.push(t);
  positions.push(x);

  updateTable();
  drawXTGraph();
  computeVelocity();
  drawVTGraph();
}

/* -----------------------------
   速度計算
----------------------------- */
function computeVelocity() {
  vTimes = [];
  velocities = [];
  for (let i = 1; i < tapTimes.length; i++) {
    const dt = tapTimes[i] - tapTimes[i - 1];
    const dx = positions[i] - positions[i - 1];
    if (dt > 0) {
      vTimes.push((tapTimes[i] + tapTimes[i - 1]) / 2);
      velocities.push(dx / dt);
    }
  }
}

/* -----------------------------
   表の更新
----------------------------- */
function updateTable() {
  dataTableBody.innerHTML = '';

  for (let i = 0; i < tapTimes.length; i++) {
    const t = tapTimes[i];
    const x = positions[i];

    let dtStr = '-';
    let vStr = '-';

    if (i > 0) {
      const dt = tapTimes[i] - tapTimes[i - 1];
      const dx = positions[i] - positions[i - 1];
      dtStr = dt.toFixed(3);
      vStr = (dx / dt).toFixed(3);
    }

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${i + 1}</td>
      <td>${t.toFixed(3)}</td>
      <td>${x.toFixed(3)}</td>
      <td>${dtStr}</td>
      <td>${vStr}</td>
    `;
    dataTableBody.appendChild(tr);
  }
}

/* -----------------------------
   キャンバスクリア
----------------------------- */
function clearCanvas(canvas) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

/* -----------------------------
   散布図描画関数
----------------------------- */
function drawScatterGraph(canvas, xs, ys, xLabel, yLabel, color) {
  const ctx = canvas.getContext('2d');
  clearCanvas(canvas);
  if (xs.length === 0) return;

  const margin = 40;
  const width  = canvas.width  - margin * 2;
  const height = canvas.height - margin * 2;

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const safMinX = Math.min(0, minX);
  const safMaxX = Math.max(0, maxX === minX ? minX + 1 : maxX);

  const rawMinY = Math.min(0, minY);
  const rawMaxY = Math.max(0, maxY);
  const yRange  = (rawMaxY - rawMinY) || 1;
  const safMinY = rawMinY - 0.05 * yRange;
  const safMaxY = rawMaxY + 0.05 * yRange;

  const toCanvasX = x =>
    margin + ((x - safMinX) / (safMaxX - safMinX)) * width;

  const toCanvasY = y =>
    margin + height - ((y - safMinY) / (safMaxY - safMinY)) * height;

  /* ---- 目盛り ---- */
  const tickCount = 5;
  const yTicks = [];
  const yStep = (safMaxY - safMinY) / (tickCount - 1);

  for (let i = 0; i < tickCount; i++) {
    yTicks.push(safMinY + i * yStep);
  }
  if (safMinY < 0 && safMaxY > 0) {
    const idx = Math.round((0 - safMinY) / yStep);
    if (idx >= 0 && idx < yTicks.length) yTicks[idx] = 0;
  }

  const xTicks = [];
  const xStep = (safMaxX - safMinX) / (tickCount - 1);

  for (let i = 0; i < tickCount; i++) {
    xTicks.push(safMinX + i * xStep);
  }
  if (safMinX < 0 && safMaxX > 0) {
    const idx = Math.round((0 - safMinX) / xStep);
    if (idx >= 0 && idx < xTicks.length) xTicks[idx] = 0;
  }

  /* ---- グリッド線 ---- */
  ctx.save();
  ctx.strokeStyle = 'rgba(148,163,184,0.18)';
  ctx.setLineDash([2,6]);

  yTicks.forEach(v => {
    const cy = toCanvasY(v);
    ctx.beginPath();
    ctx.moveTo(margin, cy);
    ctx.lineTo(margin + width, cy);
    ctx.stroke();
  });

  xTicks.forEach(v => {
    const cx = toCanvasX(v);
    ctx.beginPath();
    ctx.moveTo(cx, margin);
    ctx.lineTo(cx, margin + height);
    ctx.stroke();
  });

  /* 0 の線を強調 */
  ctx.strokeStyle = 'rgba(148,163,184,0.35)';
  ctx.setLineDash([4,6]);
  if (safMinX < 0 && safMaxX > 0) {
    const cx0 = toCanvasX(0);
    ctx.beginPath();
    ctx.moveTo(cx0, margin);
    ctx.lineTo(cx0, margin + height);
    ctx.stroke();
  }
  if (safMinY < 0 && safMaxY > 0) {
    const cy0 = toCanvasY(0);
    ctx.beginPath();
    ctx.moveTo(margin, cy0);
    ctx.lineTo(margin + width, cy0);
    ctx.stroke();
  }
  ctx.restore();

  /* ---- 枠 ---- */
  ctx.strokeStyle = 'rgba(148,163,184,0.9)';
  ctx.lineWidth = 1;
  ctx.strokeRect(margin, margin, width, height);

  /* ---- ラベルと目盛り ---- */
  ctx.font = '12px system-ui';
  ctx.fillStyle = 'rgba(209,213,219,0.95)';

  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(xLabel, margin + width / 2, canvas.height - 20);

  ctx.save();
  ctx.translate(16, margin + height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  yTicks.forEach(v => {
    ctx.fillText(v.toFixed(2), margin - 6, toCanvasY(v));
  });

  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  xTicks.forEach(v => {
    ctx.fillText(v.toFixed(2), toCanvasX(v), margin + height + 2);
  });

  /* ---- プロット ---- */
  ctx.fillStyle = color;
  const r = 5;
  for (let i = 0; i < xs.length; i++) {
    ctx.beginPath();
    ctx.arc(toCanvasX(xs[i]), toCanvasY(ys[i]), r, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* -----------------------------
   v-t / x-t グラフ描画
----------------------------- */
function drawXTGraph() {
  drawScatterGraph(
    xtCanvas,
    tapTimes,
    positions,
    't [s]',
    'x [m]',
    '#facc15'
  );
}

/* 最小二乗法で傾きを求める */
function computeSlope(xs, ys) {
  if (xs.length < 2) return null;
  const n = xs.length;
  let sumX = 0, sumY = 0;
  for (let i = 0; i < n; i++) {
    sumX += xs[i];
    sumY += ys[i];
  }
  const meanX = sumX / n;
  const meanY = sumY / n;

  let num = 0;
  let den = 0;
  for (let i = 0; i < n; i++) {
    const dx = xs[i] - meanX;
    const dy = ys[i] - meanY;
    num += dx * dy;
    den += dx * dx;
  }
  if (den === 0) return null;
  return num / den;  // 傾き a
}

function drawVTGraph() {
  drawScatterGraph(
    vtCanvas,
    vTimes,
    velocities,
    't（区間の中点）[s]',
    'v [m/s]',
    '#22c55e'
  );

  // 傾き（平均加速度）の計算と表示
  let a = computeSlope(vTimes, velocities);
  if (!aDisplay) return;
  if (a === null) {
    aDisplay.textContent = 'a: -';
  } else {
    aDisplay.textContent = 'a ≈ ' + a.toFixed(3) + ' m/s²';
  }
}

/* -----------------------------
   イベント
----------------------------- */
tapButton.addEventListener('click', handleTap);
startButton.addEventListener('click', startMeasurement);
stopButton.addEventListener('click', stopMeasurement);

resetButton.addEventListener('click', () => {
  resetAll();
  isMeasuring = false;
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    handleTap();
  }
});
</script>

</body>
</html>
