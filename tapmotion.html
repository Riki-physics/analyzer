<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>等間隔マーカー実験 x-t / v-t グラフ</title>
  <style>
    :root {
      /* 白基調 + 黒文字 */
      --bg: #f8fafc;
      --card-bg: #ffffff;
      --accent: #2563eb;
      --border-soft: #cbd5e1;
      --text-main: #0b0f1a;
      --text-sub: #334155;
    }
    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 1rem;
      background: linear-gradient(#f8fafc, #f1f5f9);
      color: var(--text-main);
    }

    .app {
      max-width: 1100px;
      margin: 0 auto;
    }

    header { margin-bottom: 1rem; }

    h1 {
      font-size: 1.4rem;
      font-weight: 700;
      display: flex;
      align-items: baseline;
      gap: 0.4rem;
      letter-spacing: 0.03em;
      color: var(--text-main);
    }
    h1 span.accent {
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 600;
    }

    .controls {
      background: var(--card-bg);
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      padding: 0.75rem 0.9rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
    }
    .controls-main {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
    }

    label {
      font-size: 0.9rem;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(100,116,139,0.35);
      background: rgba(248,250,252,0.95);
    }
    label span.tag {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      font-weight: 700;
    }

    input[type="number"] {
      width: 4rem;
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(100,116,139,0.45);
      background: #ffffff;
      color: var(--text-main);
      font-size: 0.9rem;
    }

    input[type="range"] {
      width: 120px;
    }

    button {
      font-size: 0.9rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(100,116,139,0.45);
      cursor: pointer;
      background: #ffffff;
      color: var(--text-main);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease, transform 0.05s ease;
    }
    button:hover {
      transform: translateY(-1px);
      background: #f1f5f9;
      border-color: rgba(100,116,139,0.65);
    }

    .hint {
      font-size: 0.78rem;
      color: var(--text-sub);
      line-height: 1.4;
      margin-left: auto;
      max-width: 420px;
    }

    .tap-area-wrapper {
      margin-top: 0.9rem;
      display: flex;
      justify-content: center;
    }
    #tapButton {
      width: min(420px, 100%);
      height: 22vh;
      min-height: 130px;
      max-height: 220px;
      font-size: 1.3rem;
      font-weight: 650;
      border-radius: 18px;
      border: 2px solid rgba(37,99,235,0.9);
      background: radial-gradient(circle at top, rgba(37,99,235,0.12), rgba(255,255,255,0.98));
      box-shadow:
        0 12px 28px rgba(0,0,0,0.12),
        0 0 0 1px rgba(37,99,235,0.12);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
    }
    #tapButton span.sub {
      font-size: 0.8rem;
      color: var(--text-sub);
      font-weight: 400;
    }
    #tapButton:active {
      transform: translateY(2px) scale(0.99);
      background: radial-gradient(circle at top, rgba(37,99,235,0.18), rgba(255,255,255,0.98));
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 0.8rem;
      margin-top: 0.8rem;
    }
    @media (max-width: 980px) {
      .layout { grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); }
    }
    @media (max-width: 780px) {
      .controls { flex-direction: column; align-items: flex-start; }
      .hint { margin-left: 0; }
      .layout { grid-template-columns: minmax(0, 1fr); }
    }

    .card {
      background: var(--card-bg);
      border-radius: 14px;
      border: 1px solid rgba(100,116,139,0.35);
      padding: 0.55rem 0.7rem 0.65rem;
      box-shadow: 0 10px 26px rgba(0,0,0,0.08);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(37,99,235,0.06), transparent 60%);
      pointer-events: none;
    }

    .card h2 {
      font-size: 0.98rem;
      margin: 0 0 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      letter-spacing: 0.02em;
      color: var(--text-main);
    }
    .card h2 span.badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(37,99,235,0.55);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
      background: rgba(37,99,235,0.06);
    }

    .small {
      font-size: 0.78rem;
      color: var(--text-sub);
      line-height: 1.4;
      margin-top: 0.3rem;
    }

    canvas {
      width: 100%;
      height: 200px;
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid rgba(100,116,139,0.35);
      display: block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.76rem;
      color: var(--text-main);
    }
    th, td {
      border-bottom: 1px solid rgba(100,116,139,0.25);
      padding: 0.15rem 0.25rem;
      text-align: right;
      white-space: nowrap;
      color: var(--text-main);
    }
    th {
      font-weight: 700;
      color: var(--text-sub);
      background: rgba(241,245,249,0.95);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tbody tr:nth-child(2n) td { background: rgba(248,250,252,0.95); }
    tbody tr:nth-child(2n+1) td { background: rgba(255,255,255,1); }
    tbody tr:hover td { background: rgba(37,99,235,0.08); }

    td:first-child, th:first-child { text-align: center; }

    .table-wrap {
      max-height: 260px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(100,116,139,0.35);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.6);
      background: #ffffff;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        等間隔マーカー実験
        <span class="accent">Tap → x-t / v-t graph</span>
      </h1>
    </header>

    <section class="controls">
      <div class="controls-main">
        <label>
          <span class="tag">marker</span>
          Δx:
          <input id="dxSlider" type="range" min="0.01" max="1.00" step="0.01" value="0.10" />
          <input id="dxInput" type="number" step="0.01" value="0.10" /> m
        </label>

        <!-- ★ 測定開始ボタンは削除（タップした瞬間から測定開始） -->
        <button id="stopButton">■ 測定停止</button>
        <button id="resetButton">⟳ リセット</button>
      </div>

      <div class="hint">
        下のエリアをタップ（または <strong>Space</strong>）すると<strong>その瞬間から自動で測定開始</strong>します。<br>
        1回目の記録を <strong>x = 0</strong> とし、
        <strong>x = (タップ番号 − 1) × Δx</strong> として計算します。<br>
        止めたいときは <strong>「測定停止」</strong>、やり直すときは <strong>「リセット」</strong> を押してください。
      </div>
    </section>

    <div class="tap-area-wrapper">
      <button id="tapButton">
        タップして記録
        <span class="sub">（Space キーも可 / 停止中は無効）</span>
      </button>
    </div>

    <section class="layout">
      <article class="card">
        <h2>
          データ一覧
          <span class="badge">log</span>
        </h2>
        <div class="table-wrap">
          <table id="dataTable">
            <thead>
              <tr>
                <th>#</th>
                <th>t [s]</th>
                <th>x [m]</th>
                <th>区間Δt [s]</th>
                <th>区間v [m/s]</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </article>

      <article class="card">
        <h2>
          x-t グラフ
          <span class="badge">position</span>
        </h2>
        <canvas id="xtCanvas" width="400" height="240"></canvas>
      </article>

      <article class="card">
        <h2>
          v-t グラフ
          <span class="badge">velocity & a</span>
        </h2>
        <canvas id="vtCanvas" width="400" height="240"></canvas>
        <div class="small">
          v は「2点間の平均速度」。プロットした時刻は、その区間の <strong>時間の中点</strong> です。<br>
          v-t グラフの<strong>傾き（最小二乗直線の傾き）</strong>を平均加速度 a とみなします。<br>
          現在の推定値：<strong id="aDisplay">a: -</strong>（単位：m/s²）
        </div>
      </article>
    </section>
  </div>

<script>
/* -----------------------------
   データ管理
----------------------------- */
let tapTimes = [];
let positions = [];
let vTimes = [];
let velocities = [];

let startTime = null;

/* ★ 測定開始ボタン廃止：最初のタップで自動開始。
   初期状態は「測定中」にしておく（停止ボタンで止める）。 */
let isMeasuring = true;

const dxInput     = document.getElementById('dxInput');
const dxSlider    = document.getElementById('dxSlider');
const tapButton   = document.getElementById('tapButton');
const stopButton  = document.getElementById('stopButton');
const resetButton = document.getElementById('resetButton');
const dataTableBody = document.querySelector('#dataTable tbody');

const xtCanvas = document.getElementById('xtCanvas');
const vtCanvas = document.getElementById('vtCanvas');
const aDisplay = document.getElementById('aDisplay');

function nowSec() {
  return performance.now() / 1000;
}

/* -----------------------------
   Δx 入力とスライダーの連動
----------------------------- */
dxSlider.addEventListener('input', () => {
  dxInput.value = parseFloat(dxSlider.value).toFixed(2);
});
dxInput.addEventListener('input', () => {
  const v = parseFloat(dxInput.value);
  if (!isNaN(v)) {
    const clamped = Math.min(1.0, Math.max(0.01, v));
    dxInput.value = clamped.toFixed(2);
    dxSlider.value = clamped.toFixed(2);
  }
});

/* -----------------------------
   リセット
----------------------------- */
function resetAll() {
  tapTimes = [];
  positions = [];
  vTimes = [];
  velocities = [];
  startTime = null;
  dataTableBody.innerHTML = '';
  clearCanvas(xtCanvas);
  clearCanvas(vtCanvas);
  if (aDisplay) aDisplay.textContent = 'a: -';
}

/* -----------------------------
   測定停止
----------------------------- */
function stopMeasurement() {
  isMeasuring = false;
}

/* -----------------------------
   タップ処理（最初のタップでスタート時刻を決める）
----------------------------- */
function handleTap() {
  if (!isMeasuring) return; // 停止中は無視

  const dx = parseFloat(dxInput.value) || 0.1;
  const tNow = nowSec();

  if (startTime === null) startTime = tNow; // ★ 自動スタート
  const t = tNow - startTime;

  const index = tapTimes.length;
  const x = index * dx;

  tapTimes.push(t);
  positions.push(x);

  updateTable();
  drawXTGraph();
  computeVelocity();
  drawVTGraph();
}

/* -----------------------------
   速度計算
----------------------------- */
function computeVelocity() {
  vTimes = [];
  velocities = [];
  for (let i = 1; i < tapTimes.length; i++) {
    const dt = tapTimes[i] - tapTimes[i - 1];
    const dx = positions[i] - positions[i - 1];
    if (dt > 0) {
      vTimes.push((tapTimes[i] + tapTimes[i - 1]) / 2);
      velocities.push(dx / dt);
    }
  }
}

/* -----------------------------
   表の更新
----------------------------- */
function updateTable() {
  dataTableBody.innerHTML = '';

  for (let i = 0; i < tapTimes.length; i++) {
    const t = tapTimes[i];
    const x = positions[i];

    let dtStr = '-';
    let vStr = '-';

    if (i > 0) {
      const dt = tapTimes[i] - tapTimes[i - 1];
      const dx = positions[i] - positions[i - 1];
      dtStr = dt.toFixed(3);
      vStr = (dx / dt).toFixed(3);
    }

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${i + 1}</td>
      <td>${t.toFixed(3)}</td>
      <td>${x.toFixed(3)}</td>
      <td>${dtStr}</td>
      <td>${vStr}</td>
    `;
    dataTableBody.appendChild(tr);
  }
}

/* -----------------------------
   キャンバスクリア
----------------------------- */
function clearCanvas(canvas) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

/* -----------------------------
   散布図描画関数
   ★ 目盛り数字と軸ラベルが被らないようにマージンを調整
----------------------------- */
function drawScatterGraph(canvas, xs, ys, xLabel, yLabel, color) {
  const ctx = canvas.getContext('2d');
  clearCanvas(canvas);
  if (xs.length === 0) return;

  // ★ bottom を厚めにして「目盛り数字」と「x軸ラベル」を分離
  const m = { left: 48, right: 18, top: 18, bottom: 54 };

  const plotW = canvas.width  - m.left - m.right;
  const plotH = canvas.height - m.top  - m.bottom;

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const safMinX = Math.min(0, minX);
  const safMaxX = Math.max(0, maxX === minX ? minX + 1 : maxX);

  const rawMinY = Math.min(0, minY);
  const rawMaxY = Math.max(0, maxY);
  const yRange  = (rawMaxY - rawMinY) || 1;
  const safMinY = rawMinY - 0.05 * yRange;
  const safMaxY = rawMaxY + 0.05 * yRange;

  const toCanvasX = x =>
    m.left + ((x - safMinX) / (safMaxX - safMinX)) * plotW;

  const toCanvasY = y =>
    m.top + plotH - ((y - safMinY) / (safMaxY - safMinY)) * plotH;

  /* ---- 目盛り ---- */
  const tickCount = 5;

  const yTicks = [];
  const yStep = (safMaxY - safMinY) / (tickCount - 1);
  for (let i = 0; i < tickCount; i++) yTicks.push(safMinY + i * yStep);
  if (safMinY < 0 && safMaxY > 0) {
    const idx = Math.round((0 - safMinY) / yStep);
    if (idx >= 0 && idx < yTicks.length) yTicks[idx] = 0;
  }

  const xTicks = [];
  const xStep = (safMaxX - safMinX) / (tickCount - 1);
  for (let i = 0; i < tickCount; i++) xTicks.push(safMinX + i * xStep);
  if (safMinX < 0 && safMaxX > 0) {
    const idx = Math.round((0 - safMinX) / xStep);
    if (idx >= 0 && idx < xTicks.length) xTicks[idx] = 0;
  }

  /* ---- グリッド線（薄いグレー） ---- */
  ctx.save();
  ctx.strokeStyle = 'rgba(100,116,139,0.25)';
  ctx.setLineDash([2,6]);

  yTicks.forEach(v => {
    const cy = toCanvasY(v);
    ctx.beginPath();
    ctx.moveTo(m.left, cy);
    ctx.lineTo(m.left + plotW, cy);
    ctx.stroke();
  });

  xTicks.forEach(v => {
    const cx = toCanvasX(v);
    ctx.beginPath();
    ctx.moveTo(cx, m.top);
    ctx.lineTo(cx, m.top + plotH);
    ctx.stroke();
  });

  /* 0 の線を少し強調 */
  ctx.strokeStyle = 'rgba(51,65,85,0.55)';
  ctx.setLineDash([4,6]);
  if (safMinX < 0 && safMaxX > 0) {
    const cx0 = toCanvasX(0);
    ctx.beginPath();
    ctx.moveTo(cx0, m.top);
    ctx.lineTo(cx0, m.top + plotH);
    ctx.stroke();
  }
  if (safMinY < 0 && safMaxY > 0) {
    const cy0 = toCanvasY(0);
    ctx.beginPath();
    ctx.moveTo(m.left, cy0);
    ctx.lineTo(m.left + plotW, cy0);
    ctx.stroke();
  }
  ctx.restore();

  /* ---- 枠（黒） ---- */
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.strokeRect(m.left, m.top, plotW, plotH);

  /* ---- ラベルと目盛り（黒） ---- */
  ctx.font = '12px system-ui';
  ctx.fillStyle = '#000';

  // x軸ラベル（最下段）
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(xLabel, m.left + plotW / 2, canvas.height - 10);

  // y軸ラベル（左外側、少し上に逃がす）
  ctx.save();
  ctx.translate(16, m.top + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // y目盛り数字
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  yTicks.forEach(v => {
    ctx.fillText(v.toFixed(2), m.left - 8, toCanvasY(v));
  });

  // x目盛り数字（ラベルと被らないよう「少し上」に配置）
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  xTicks.forEach(v => {
    ctx.fillText(v.toFixed(2), toCanvasX(v), m.top + plotH + 6);
  });

  /* ---- プロット（色は元のまま） ---- */
  ctx.fillStyle = color;
  const r = 5;
  for (let i = 0; i < xs.length; i++) {
    ctx.beginPath();
    ctx.arc(toCanvasX(xs[i]), toCanvasY(ys[i]), r, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* -----------------------------
   v-t / x-t グラフ描画
----------------------------- */
function drawXTGraph() {
  drawScatterGraph(
    xtCanvas,
    tapTimes,
    positions,
    't [s]',
    'x [m]',
    '#facc15'
  );
}

/* 最小二乗法で傾きを求める */
function computeSlope(xs, ys) {
  if (xs.length < 2) return null;
  const n = xs.length;
  let sumX = 0, sumY = 0;
  for (let i = 0; i < n; i++) {
    sumX += xs[i];
    sumY += ys[i];
  }
  const meanX = sumX / n;
  const meanY = sumY / n;

  let num = 0;
  let den = 0;
  for (let i = 0; i < n; i++) {
    const dx = xs[i] - meanX;
    const dy = ys[i] - meanY;
    num += dx * dy;
    den += dx * dx;
  }
  if (den === 0) return null;
  return num / den;
}

function drawVTGraph() {
  drawScatterGraph(
    vtCanvas,
    vTimes,
    velocities,
    't（区間の中点）[s]',
    'v [m/s]',
    '#22c55e'
  );

  let a = computeSlope(vTimes, velocities);
  if (!aDisplay) return;
  if (a === null) {
    aDisplay.textContent = 'a: -';
  } else {
    aDisplay.textContent = 'a ≈ ' + a.toFixed(3) + ' m/s²';
  }
}

/* -----------------------------
   イベント
----------------------------- */
tapButton.addEventListener('click', handleTap);
stopButton.addEventListener('click', stopMeasurement);

resetButton.addEventListener('click', () => {
  resetAll();
  isMeasuring = true;   // ★ リセット後はすぐ測定できる
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    handleTap();
  }
});
</script>

</body>
</html>